<html><body><p>So I'm not sure if I fully grok STM, but my basic understanding of the workflow for a transaction is this:<br><br>1. Make a copy of whatever it is you're planning to use, ie, 'stuff'.<br>2. Do anything that doesn't have side effects (writing to memory/disk).<br>3. Acquire a lock &amp; compare the state of the parts of 'stuff' you want to change to the current state.<br>4a. If 'stuff to write' is unchanged, write it and release lock.<br>4b. Otherwise, release lock and restart transaction.<br><br>With the context manager, how is 'stuff' determined? Does it record everything in locals()?  That seems like it might be excessive. Would it make sense to expose 'stuff' to the programmer?<br><br>If you were to expose 'stuff' to the programmer, I'd think you'd want a new local context where the only variables available were those explicitly specified as 'stuff' (and builtins, etc) so as to avoid congruency accidents. Something like:<br><br>with atomic(f, x, y, z, q) as f, x, y, z, q:<br>    z += f(x, y)<br>    y = x<br>    x = q.pop()<br><br>This would also help remind folks to keep their transactions small.<br><br>Furthermore, this could easily be transformed into a very useful (function) decorator that uses the function's arguments as the 'stuff'.<br><br>Am I missing something? Are my suggestions reasonable?</p></body></html>