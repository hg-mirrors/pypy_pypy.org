<html><body><p>@Kris: indeed.  I found out a way that should in all cases either work or raise an exception if unsupported (and not unexpectedly deadlock).<br><br>The unsupported situation is: we are in a "with atomic" block trying to acquire a lock, and this lock is acquired already.  In this case, there is nothing the interpreter can do automatically.  It can only complain rather than deadlocking: no other thread is going to run in parallel to release the lock.<br><br>This should let the "common use case" work, which is locks used as scoped mutexes.  Caveat: only as long as you use them either only in "with atomic" blocks --- because they appear to be fully serialized, so the mutex will never block --- or only outside "with atomic" blocks.<br><br>This leaves the case of mixed usage as unsupported, but I don't see how it could reasonably be supported.<br><br>So for now, pypy-stm will raise "oups deadlock" if you try to use "print" statements both inside and outside atomic blocks in parallel...  that's the best I could come up with so far.</p></body></html>