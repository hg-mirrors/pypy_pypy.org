<html><body><p>@Jonas: it is not always obvious at development time -- to say the least -- how to avoid all conflicts.  Think about how hard it is to add automatic GC to C++ in a large project: it's messy but you might get pretty far with just reference counting -- until some point when you loose because of cyclic references.  If instead you had used a proper GC-managed language, the problem would just not exist.  It's the same about Transactional Memory and conflicts: you can either think harder and harder about using locks correctly, until your programs becomes really messy; then you give up and use TM, solving the issue instantly and letting you think again about your original problem.<br><br>Regarding the transaction size: with a good implementation, big transactions should not be slower than small transactions.  The only potential drawback of having big transactions is that the risks of conflicts might increase (depending on your program).<br><br>Note that this question has a different answer for Python than for C, where code outside transactions runs faster than code within transactions.  It is not so in Python.  The reason is that transactions are always needed in Python: either explicitly, or implicitly in order to protect the interpreter structures (in replacement of the famous GIL).</p></body></html>