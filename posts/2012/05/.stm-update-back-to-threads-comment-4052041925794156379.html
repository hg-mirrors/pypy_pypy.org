<html><body><p>@Kris: ah, interesting.  You did the same as what I attempted in my hack of CPython at https://bitbucket.org/arigo/cpython-withatomic .  This didn't really work out, though, because the stdlib (including file objects) use regular locks.  A simple "print" in an atomic block could lead to deadlocks: the atomic block can block waiting for the stdout's file lock to be released, but it does so without releasing the GIL.  Now the lock would typically be released by another thread --- if only it could grab the GIL for a short while.<br><br>You can see the workaround I found in the last few commit messages of the above repository, but I'm not satisfied with it...  In general I'm still unsure what the best way is.  For now in pypy-stm I'm going to hack on a case-by-case basis to convert the locks to atomic sections.<br><br>Perhaps it is possible to do it semi-generically, e.g. convert all syntactically nested "with lock:" statements in the user code into "with atomic:" statements (similar to next year's Intel CPUs, which will have "lock elision" to help convert from lock-based to HTM programs).  As far as I know, this idea doesn't work in all situations, e.g. if you acquire a lock in one thread and release it in another thread.<br><br>As far as I can say, this issue is the main blocker preventing any further progress on the CPython side.  It is certainly the reason I stopped pushing for it last year.</p></body></html>