<html><body><p>Jesus Christ why don't we all just spend 5 min fiddling with the multiprocessing module and learn how to partition execution and queues like we partition sequences of statements into functions?  So sick of GIL articles and the obsession with not learning how to divide up the work and communicate.  In some ways the need to recognize narrow channels where relatively small amounts of data are being channeled through relatively intense blocks of execution and create readable, explicit structure around those blocks might actually improve the comprehensibility of some code I've seen.  Getting a little tired of seeing so much effort by excellent, essential, dedicated Python devs getting sucked up by users who won't get it.<br><br>I think users are driving this speed-for-free obsession way to far.  If anything bugs in a magical system are harder to find than understanding explicit structure and explicit structure that's elegant is neither crufty nor slow.  Eventually, no interpreter will save a bad programmer.  Are we next going to enable the novice "Pythonista" to forego any knowledge of algorithms?  <br><br>We -need- JIT on production systems to get response times down for template processing without micro-caching out the wazoo.  These types of services are already parallel by nature of the servers and usually I/O bound except for the few slow parts.  Cython already serves such an excellent roll for both C/C++ API's AND speed AND optimizing existing python code with minimal changes.  JIT PyPy playing well with Cython would make Python very generally uber.  Users who actually get multiprocessing and can divide up the workflow won't want a slower implementation of any other kind.  Getting a somewhat good solution for 'free' is not nearly as appealing as the additional headroom afforded by an incremental user cost (adding some strong typing or patching a function to work with pypy/py3k).</p></body></html>