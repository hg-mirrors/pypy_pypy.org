<html><body><p>@Anonymous: "So you may do all the book-keeping yourself in software, but then at commit time use HTM.": I don't see how (or the point), can you be more explicit or post a link?<br><br>@Anonymous: I'm not saying that STM is the final solution to all problems.  Some classes of problems have other solutions that work well so far and I'm not proposing to change them.  Big servers can naturally handle big loads just by having enough processes.  What I'm describing instead is a pure language feature that may or may not help in particular cases --- and there are other cases than the one you describe where the situation is very different and multiprocessing doesn't help at all.  Also, you have to realise that any argument "we will never need feature X because we can work around it using hack Y" is bound to lose eventually: at least some people in some cases will need the clean feature X because the hack Y is too complicated to learn or use correctly.<br><br>@Benjamin: "atomic" actually means "not decomposable", not necessarily "as small as possible".  This focus on smallness of transaction IMO is an artefact of last decade's research focus.  In my posts I tend to focus on large transaction as a counterpoint: in the use cases I have in mind there is no guarantee that all transactions will be small.  Some of them may be, but others not, and this is a restriction.  In things like "one iteration through this loop = one transaction", some of these iterations go away and do a lot of stuff.</p></body></html>