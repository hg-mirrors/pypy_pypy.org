<html><body><p>@gasche: I know about Haskell, Clojure and Scala, and I just read the two blog posts you pointed to.<br><br>I'm not talking about giving explicit TM to the end programmers.  I'm instead considering TM as an internal, implementation-only feature.  That makes it very similar to GCs.<br><br>I know the points and issues of traditional TM systems, which are nicely reported by Joe Duffy in "A (brief) retrospective on transactional memory".  These are of course perfectly valid issues, but I think they do not apply (or "not that much") in the particular context I'm talking about.  For example, this includes the large sections about nested transactions, and about consistency between the transactional and non-transactional worlds (Weak or Strong Atomicity, The Privatization Problem).  Even "Where is the Killer App?" is obvious in this case: any existing Twisted App is potentially a Killer App.<br><br>Sorry for not including references to papers.  I must admit I don't know any paper that describes a similar use case for TM.</p></body></html>