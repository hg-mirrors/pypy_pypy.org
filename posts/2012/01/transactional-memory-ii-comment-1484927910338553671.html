<html><body><p>Your idea could work for other easy to inject into points, such as loops, and comprehensions.  Especially with much of the work in pypy already done for identifying information about loops.<br><br>How does this compare to grand central dispatch and blocks?  http://en.wikipedia.org/wiki/Grand_Central_Dispatch<br><br>Events are a very good way to model concurrency, and are widely used.  It is a great place to dispatch concurrency into parallelism.<br><br>Closures/blocks provide a fairly decent way to get some of the protection of STM - and in many programs give you the 80% solution.  For code that plays nicely and avoids mutable, or global data - this works.  Luckily, a lot of event based code is already written in this way.  As you say, they are "generally mostly independent".<br><br>Making the bad cases a quick fail, like in JavaScript worker threads could be an ok option.  As soon as someone tries to access global data(do a system call, access the DOM, or access data outside the closure even), the program would fail there.  Then you could fix those cases, or "add non-determinism" as you say.  I think I'd prefer fail fast here, rather than have to detect these problems, and have them silently pass by.<br><br>You still have scheduling problems, and trying to figure out task size.  As well, this does not solve lots of other problems.  However, it is cool that it could be applied automatically, and probably 'safely'.<br><br>Another random thought... you could probably mark chunks of code as 'pure' as your run through them, and if they do a system call or mutate global data mark them as 'unpure' and don't try them again.<br><br>I very much look forward to reading your results as you implement more.</p></body></html>