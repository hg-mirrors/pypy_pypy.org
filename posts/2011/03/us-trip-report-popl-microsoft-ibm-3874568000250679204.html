<html><body><p>Some notes from my recent trip (from 23rd of January to 17th of February) to the
US where, I presented PyPy at various scientifically oriented places. In
summary, there seems to be quite a bit of interest in PyPy within the research
community, details below.</p>
<div class="section" id="pepm-popl-stop">
<h2>PEPM/POPL/STOP</h2>
<p>From the 24th to the 29th of January I was in Austin, Texas at the <a class="reference external" href="http://www.cse.psu.edu/popl/11/">POPL
conference</a>, where I gave a talk at one of the workshops, <a class="reference external" href="http://www.program-transformation.org/PEPM11">PEPM</a> (Partial
Evaluation and Program Manipulation). The title of our <a class="reference external" href="http://codespeak.net/svn/pypy/extradoc/talk/pepm2011/bolz-allocation-removal.pdf">paper</a> is
"Allocation Removal by Partial Evaluation in a Tracing JIT", the abstract is:</p>
<blockquote>
The performance of many dynamic language implementations suffers from high
allocation rates and runtime type checks. This makes dynamic languages less
applicable to purely algorithmic problems, despite their growing
popularity. In this paper we present a simple compiler optimization based
on online partial evaluation to remove object allocations and runtime type
checks in the context of a tracing JIT. We evaluate the optimization using
a Python VM and find that it gives good results for all our (real-life)
benchmarks.</blockquote>
<p>The talk (<a class="reference external" href="http://codespeak.net/svn/pypy/extradoc/talk/pepm2011/presentation/bolz-allocation-removal-talk.pdf">slides</a>) seemed to be well-received and there was
a good discussion afterwards. PEPM in general was a very enjoyable workshop
with many interesting talks on partial evaluation (which I am very interested
in) and a great keynote by Olivier Danvy about "A Walk in the Semantic Park".</p>
<p><strong>POPL</strong> itself was a bit outside of the area I am most knowledgeable in, most of
the talks being on formal topics. Some of the talks that stuck to my mind:</p>
<ul class="simple">
<li><em>"The Design of Kodu: A Tiny Visual Programming Language for Children on the
Xbox 360"</em>, the keynote by Matthew MacLaurin from Microsoft Research. I didn't
know about <a class="reference external" href="http://fuse.microsoft.com/project/kodu.aspx">Kodu</a> before, and was very impressed by it.</li>
</ul>
<ul class="simple">
<li><em>"Automating String Processing in Spreadsheets using Input-Output Examples"</em>
(<a class="reference external" href="http://research.microsoft.com/en-us/um/people/sumitg/pubs/popl10-synthesis.pdf">paper</a>) by Sumit Gulwani (also from MS Research) describes a plugin to Excel
that can automate many common string processing tasks by giving a couple of
examples, which are then abstracted into a generic string manipulation. Very
cool.</li>
</ul>
<ul class="simple">
<li><em>"Dynamic Inference of Static Types for Ruby"</em> (<a class="reference external" href="http://www.cs.umd.edu/~jfoster/papers/popl11.pdf">paper</a>) by   Michael Furr,
Jong-hoon (David) An, Jeffrey S. Foster and Michael Hicks describes an
approach to type inference that works by observing the actual types seen
during unit-testing. Similar things have been done a few times before,
however, the paper actually gives a correctness result.</li>
</ul>
<ul class="simple">
<li><em>"The Essence of Compiling with Traces"</em> (<a class="reference external" href="http://rfrn.org/~shu/papers/popl11-full.pdf">paper</a>) by Shu-Yu Guo and Jens
Palsberg describes a formalization of a simple imperative language and
proves that executing it using trace compilation will do exactly the same
thing than using an interpreter. It also looks at what conditions an
optimization on traces must fulfill to still produce valid results.</li>
</ul>
<p>After the main conference, I took part in the <a class="reference external" href="http://wrigstad.com/stop11/">STOP</a> (Scripts to Programs)
workshop. It had a great keynote <em>"Scripting in a Concurrent World"</em> by John Field
about the <a class="reference external" href="http://www.thorn-lang.org/">Thorn language</a> and a few interesting other talks.</p>
</div>
<div class="section" id="microsoft-research">
<h2>Microsoft Research</h2>
<p>After POPL I went to Redmond to visit Microsoft Research for a week,
specifically the <a class="reference external" href="http://research.microsoft.com/en-us/groups/rise/">RiSE group</a>. This is the group that did the <a class="reference external" href="http://research.microsoft.com/en-us/projects/spur/">SPUR project</a>,
a meta-tracing JIT for C# applied to a JavaScript interpreter in C#. I <a class="reference external" href="http://morepypy.blogspot.com/2010/07/comparing-spur-to-pypy.html">compared
PyPy to SPUR</a> last year. I am very grateful for Microsoft for inviting me
there.</p>
<p>At Microsoft I gave a talk about "PyPy's Approach to Implementing Dynamic
Languages Using a Tracing JIT Compiler", the slides of which can be found
<a class="reference external" href="http://codespeak.net/svn/pypy/extradoc/talk/microsoft-jan-2011/talk.pdf">here</a>. The talk was <a class="reference external" href="http://research.microsoft.com/apps/video/dl.aspx?id=144687">filmed and is online</a>. People seemed to be impressed
with the "product qualities" of PyPy, e.g. the buildbot infrastructure and
speed tracking website.</p>
<p>The rest of the time I discussed with various researchers in the RiSE group,
particularly with <a class="reference external" href="http://research.microsoft.com/en-us/people/nikolait/">Nikolai Tillmann</a>. We talked a lot about similarities and
differences between SPUR and PyPy and tried to understand our respective projects
better. SPUR is a really great project and I learned a lot in the discussions,
for example about the optimizations and heuristics their trace compiler uses.</p>
<p>Another very cool project done by the RiSE group that I learned more about is
<a class="reference external" href="http://research.microsoft.com/en-us/projects/pex/">PEX</a>. PEX is a unit test generator for C# that tries to produce unit tests for
so-far untested execution paths within methods. There is an <a class="reference external" href="http://www.pexforfun.com/">online puzzle
version</a> of it, if you want to get an impression of the technology (including a
very impressive C# IDE in the browser).</p>
</div>
<div class="section" id="ibm">
<h2>IBM</h2>
<p>For the last part of the trip I stayed in New York City for two weeks,
mostly as a vacation. However, I also visited IBM <a class="reference external" href="http://www.watson.ibm.com/index.shtml">Watson Research Center</a> for
two days, to which I had been invited by <a class="reference external" href="https://researcher.ibm.com/researcher/view.php?person=us-edelsohn">David Edelsohn</a>.</p>
<p>The first day I gave the same presentation I had given at Microsoft (with some
improvements to the <a class="reference external" href="http://codespeak.net/svn/pypy/extradoc/talk/ibm-feb-2011/talk.pdf">slides</a>), again it was quite well received. The rest of
the time I spent in (very fruitful) discussions with various people and teams,
among them the <a class="reference external" href="https://researcher.ibm.com/researcher/view_project.php?id=122">Liquid Metal</a> team and the <a class="reference external" href="http://www.thorn-lang.org/">Thorn</a> team.</p>
<p>The second day I met with members of the FIORANO group, who are working on
dynamic compilation for dynamic languages and Java. They explored various ways
to speed up Python, both by improving the CPython interpreter as well as with
JIT compilation techniques.</p>
<p>Another of their projects is to add a trace compiler to IBM's J9 JVM, about
which the <a class="reference external" href="https://researcher.ibm.com/researcher/files/us-pengwu/CGO2011_TraceJIT.pdf">paper</a> "A Trace-based Java JIT Compiler Retrofitted from a
Method-based Compiler" is going to appear at <a class="reference external" href="http://www.cgo.org/cgo2011/">CGO</a>. I discussed tracing JITs with
<a class="reference external" href="https://researcher.ibm.com/researcher/view.php?person=us-pengwu">Peng Wu</a>, one of the authors of that paper. Peng tries to systematically look at
the various heuristics found in the different VMs that use tracing JITs. This
is a very different perspective from the one I usually have, focusing on how to
improve PyPy's specific heuristics. Therefore that discussion helped me thinking
about the issues more generally.</p>
<p>Another goal of the group is to try to find benchmarks that are representative
for typical Python workloads, which is something that has been done very
carefully for Java e.g. when developing the <a class="reference external" href="http://dacapobench.org/">DaCapo</a> benchmark suite. The
benchmarks that the Python community uses have not been selected in such a
careful and measured way, so I think that trying to be more systematic there is
a very worthwhile endeavour.</p></div></body></html>