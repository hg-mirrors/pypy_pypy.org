<html><body><p>@Anonymous: this case can be handled on a case-by-case basis (e.g. special-casing "prints" to buffer), but it also has a general solution: we turn the transaction into an "inevitable" transaction, i.e. one which cannot fail.<br><br>I already have support for this in my demo code, because it is needed to handle the cases where the nesting of the C program is such that setjmp/longjmp can no longer work.  The typical example is the RETURN_VALUE bytecode.  It starts a transaction, returns to the caller by popping off some C frames, then ends the transaction in the caller.  When we return from the C frame of the callee, in the middle of the transaction, we notice that we won't have the setjmp around any longer, so we are not allowed to abort and rollback any more.<br><br>Inevitable transactions have the property of being "a bit like" a GIL in the sense that you can only have one in total, and other transactions cannot commit before it does.  In case of the RETURN_VALUE, it's a very short transaction so it shouldn't really be a problem.  For the case of a user-specified "with atomic:" block, it can make all the other threads pause.  Not ideal, but at least better than nothing...</p></body></html>