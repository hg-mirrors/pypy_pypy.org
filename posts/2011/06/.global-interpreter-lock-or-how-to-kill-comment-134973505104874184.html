<html><body><p>@Jon Morgan:<br><br>1. We would most probably still <br>have a GIL for the CPython C<br>extensions.  Only one can run at a<br>time, but any number of PyPy<br>threads can run at the same time.<br>(This is because the CPython C <br>extensions never access PyPy's own<br>objects directly --- they cannot,<br>because PyPy's own objects can<br>move, and the C code is not<br>prepared for that.)<br><br>2. Logging to a file is done with a<br>call to a function like write().<br>In CPython and so far in PyPy, the<br>call to write() is preceded by<br>"release GIL" and followed by <br>"re-acquire GIL".  In the STM PyPy,<br>it would be preceded by "end the<br>current transaction" and "start the<br>next transaction".  This gives the<br>same behavior.  But we may have to<br>think a bit harder about writes<br>that are buffered, because it seems<br>that if all threads write into the<br>same buffer then it will cause many<br>transaction conflicts.<br><br>Note however that we are talking<br>here about very short-lived<br>transactions.  Even if you have 20<br>threads all writing to the same log<br>file, each thread is going to run<br>much more than 20 bytecodes between<br>any two writes to the log file.<br>You only get conflicts if two of<br>these threads are running the<br>write() call at the same time, and<br>such a conflict only causes one of<br>the threads to roll back and retry<br>the write(), not more.</p></body></html>