<html><body><p>Pypy isn't faster than C, even on this example for multiple reasons:<br><br>First it's conceptual: C is almost as optimized as assembly (it's often referred to as a super assembler) so even if Pypy ends-up generating some assembly code, it has first to evaluate the runtime environment to figure out the type of variables and emit assembly code, and all this process is not free... so Pypy can only asymptotically reach the same level as C and assembly.<br><br>Second, the test is flawed: I did a slight modification that shouldn't change the results: I've inlined the add() in both python and C. Oh! surprise: Pypy keeps the same time whereas C is 4x faster than before (without inlining).<br><br>So to make it fair, we need to use the best capabilities of both languages:<br>- python: I'm sure the author provided the best python implementation, and the fact that inlining add() doesn't change results kinda proves this)<br>- C: when you inline the function you get:<br><br>[code]<br><br>static inline double add_double(double a, double b) {<br>  return a + b;<br>}<br><br>int main()<br>{<br>  unsigned int i;<br>  double a = 0.0;<br><br>  for (i = 0; i &lt; N; i++) {<br>    a += 1.0;<br>    add_double(a, a);<br>  }<br>  printf("%f\n", a);<br>}<br><br>[/code]<br><br>Results:<br>  C inlined: 1.10s<br>  C: 3.98s<br>  Pypy inlined: 3.30s<br>  Pypy: 3.28s<br><br>Conclusion:<br>- When using the right C code, on the same example C is 3 times faster than Pypy.<br>- As demonstrated, the statement that Pypy is faster than C is simply biased by a not optimizsed C code.</p></body></html>