<html><body><p>Anonymous: Wow a lot of questions, I'll try to answer them :)<br><br>1) Yes.<br><br>2) Probably not, you get the most performance gains when you have a large list, and if it's large the very-very-very-small initial transition is amortized over many elements.<br><br>3) Many of those are pure-python and will thus automatically gain these benefits, max() and min() unfortunately are not.<br><br>4) Probably not, we don't expose this data in any other place nor do we have any APIs for it.<br><br>5) I suppose in theory, again we have no API for it.<br><br>6) No, it wouldn't be, since that's not a part of the list API.  We don't define the language, we just implement it (faster).<br><br>7) No, there's no problem with this, you simply need to lock (or whatever the equivilant in STM) is the list and do the modifications.<br><br>8) No, I don't think it does.<br><br>9) Yes, it could be applied to CPython with slightly more difficulty, and it would see the memory gains.  However, it would see performance losses (as you do with teh array module on CPython) because it would need to box/unbox at every iteraction, whereas teh JIT is able to remove that.<br><br>10) Propose it to python-ideas, we don't define the language.<br><br>11) I can't understand the charts, so I can't answer this one.</p></body></html>