<html><body><p>Recently I've been doing a lot of profiling on the PyPy executables to find speed bottlenecks. <a href="http://en.wikipedia.org/wiki/Valgrind">Valgrind</a> (the original <a href="http://valgrind.org/">page</a> seems to be down) is an extremely nice tool for doing this. It has several built-in tools that give you different types of profiles. The callgrind mode provides you with a lot of information including relative call costs. The cachegrind tool gives you less information, but what it gives you (e.g. cache misses) is much more accurate. The obvious choice would be to have a way to combine the results of two profiling runs to have both. In the last days I wrote a script that does this. It's available <a href="http://codespeak.net/svn/user/fijal/pygrind">at my user's svn</a> and has a pretty intuitive command line interface. The combining calculation are not perfect yet, total costs of functions can still be a bit bogus (they can sum up to whatever) but at least the relative figures are good. This means that we can stop looking at two different types of graphs now.

An awesome tool for analyzing the profile data is <a href="http://kcachegrind.sourceforge.net/cgi-bin/show.cgi">kcachegrind.</a>

<a href="http://4.bp.blogspot.com/_5R1EBmwBBTs/R2JjKRYuTTI/AAAAAAAAAAM/LX5ktu_FcIE/s1600-h/kcachegrind.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5143782752527469874" src="http://4.bp.blogspot.com/_5R1EBmwBBTs/R2JjKRYuTTI/AAAAAAAAAAM/LX5ktu_FcIE/s320/kcachegrind.png" style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;"></a>

Which also proves that my 12'' display is to small at least for some things :-).


<b>Update:</b> pygrind is available under the MIT license.</p></body></html>