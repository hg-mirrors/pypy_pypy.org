<html><body><p>Nice - thanks!<br><br>»TransactionQueue is in part similar: your program needs to have “some chances” of parallelization before you can apply it. But I believe that the scope of applicability is much larger with TransactionQueue than with other approaches. It usually works without forcing a complete reorganization of your existing code, and it works on any Python program which has got latent and imperfect parallelism. Ideally, it only requires that the end programmer identifies where this parallelism is likely to be found«<br><br>If I understand that correctly, for STM the parallelism only needs to be <b>likely</b> and can be <b>imperfect</b>, because it can recover from errors.<br><br>This would fix a whole class of problems I experienced in OpenMP Fortran code: Turning a crash or (worse) undefined behavior into a mere performance loss - and that’s really cool!<br><br>Thank you for working on that!</p></body></html>