<html><body><p>
The <a href="http://morepypy.blogspot.com/2009/03/applying-tracing-jit-to-interpreter.html">previous post</a> about our JIT explained a bit from the 1000 km
perspective how the tracing JIT would approach a language like Python.
</p>
<p>
I would like to step a bit inside and give a zoom to some of its features that
are already working.
While probably not the most innovative, I think it's very nice to look
at the way we work with the JIT and what tools we use.
</p>
<p>
The main cool thing is that you can work on and try the JIT (including trying
it on the Python interpreter!) without even generating a single bit of
assembler. How? Let's start with something very simple. Let's take
a simple interpreter for language X.
</p>
<p>
Language X has 3 opcodes: CO_INCREASE, CO_DECREASE and CO_JUMP_BACK_3.
CO_INCREASE increase the accumulator by one, CO_DECREASE decrease
it by one, CO_JUMP_BACK_3 jump 3 opcodes back, if the accumulator is smaller
than 100 (this is only to maintain some halting conditions possible).
The interpreter for language X looks like this::
</p><p>
</p><pre>
    jitdriver = JitDriver(greens = ['i'], reds = ['res', 'a'])
    code = [CO_INCREASE, CO_INCREASE, CO_INCREASE,
            CO_JUMP_BACK_3, CO_INCREASE, CO_DECREASE]
            
    def add(res, a):
        return res + a

    def sub(res, a):
        return res - a

    def main_interpreter_loop(a):
        i = 0
        res = 0
        c = len(code)
        while i &lt; c:
            jitdriver.jit_merge_point(res=res, i=i, a=a)
            elem = code[i]
            if elem == CO_INCREASE:
                res = add(res, a)
            elif elem == CO_DECREASE:
                res = sub(res, a)
            else:
                if res &gt; 100:
                    pass
                else:
                    i = i - 3
                    jitdriver.can_enter_jit(res=res, i=i, a=a)
                    continue
            i = i + 1
        return res
</pre>
<p>
All very simple code, expect the jitdriver hints, which instruct JIT how to
behave (they are the equivalent of the ``add_to_position_key`` of last the blog
post).
</p>
<p>
Let's look how this code is processed. This will also give a glance
at how we work in this code. This particular piece can be found
on a <a href="http://codespeak.net/svn/pypy/branch/pyjitpl5">branch</a> in <tt>pypy/jit/metainterp/test/test_loop.py</tt>
and can be run with <tt>./test_all.py jit/metainterp/test/test_loop.py -k test_example -s --view</tt> from pypy directory. The <tt>-s</tt> option lets you see the debugging output, while
<tt>--view</tt> will show you some graphs. So, let's look at graphs in order:
</p>
<a href="http://4.bp.blogspot.com/_5R1EBmwBBTs/Sa_bimW0kmI/AAAAAAAAAB4/2VZMna1K_Jk/s1600-h/jit-graph-1.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5309703873151406690" src="http://4.bp.blogspot.com/_5R1EBmwBBTs/Sa_bimW0kmI/AAAAAAAAAB4/2VZMna1K_Jk/s400/jit-graph-1.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 340px;"></a>

And the same picture with a bit of zoom for the first block:

<a href="http://1.bp.blogspot.com/_5R1EBmwBBTs/Sa_bp8M4fII/AAAAAAAAACA/ShAopZhNLNQ/s1600-h/jit-graph-2.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5309703999274384514" src="http://1.bp.blogspot.com/_5R1EBmwBBTs/Sa_bp8M4fII/AAAAAAAAACA/ShAopZhNLNQ/s400/jit-graph-2.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 340px;"></a>
<p>

This is the call graph of an interpreter loop, nothing magic so far. This is an
intermediate representation of translation toolchain input. If you look around
you can follow how the opcodes are dispatched (with a chain of ifs) and helpers
called. Next graph is very boring, because it's a bit lower level representation
of the same thing (you exit with q or escape btw :).
</p>
<p>
When we exit the graph viewer, we can see the trace generated by interpreting
this graph with a given bytecode (variable <tt>code</tt> in paste above). It's something
like:
</p>
<pre>

        [compiler] ENTER
        [runner:cpu]    call__4 [(''), * GCREF hidden, 0] -&gt; 0
        [runner:cpu]    int_eq [0, 0] -&gt; True
        [runner:cpu]    int_add [9, 1] -&gt; 10
        [runner:cpu]    int_add [0, 1] -&gt; 1
        [runner:cpu]    int_lt [1, 6] -&gt; True
        [runner:cpu]    call__4 [(''), * GCREF hidden, 1] -&gt; 0
        [runner:cpu]    int_eq [0, 0] -&gt; True
        [runner:cpu]    int_add [10, 1] -&gt; 11
        [runner:cpu]    int_add [1, 1] -&gt; 2
        [runner:cpu]    int_lt [2, 6] -&gt; True
        [runner:cpu]    call__4 [(''), * GCREF hidden, 2] -&gt; 0
        [runner:cpu]    int_eq [0, 0] -&gt; True
        [runner:cpu]    int_add [11, 1] -&gt; 12
        [runner:cpu]    int_add [2, 1] -&gt; 3
        [runner:cpu]    int_lt [3, 6] -&gt; True
        [runner:cpu]    call__4 [(''), * GCREF hidden, 3] -&gt; 1
        [runner:cpu]    int_eq [1, 0] -&gt; False
        [runner:cpu]    int_eq [1, 2] -&gt; False
        [runner:cpu]    int_gt [12, 100] -&gt; False
        [runner:cpu]    int_sub [3, 3] -&gt; 0
        [compiler] LEAVE
</pre>
<p>
It's entering JIT, doing some primitive operations for bytecode dispatching
and repeating the loop. Note that at the end of the interpreted loop
(not to be confused with the interpreter loop), we see <tt>int_sub [3, 3]</tt>
which resets the bytecode position to the beginning. At this time JIT
(instructed by <tt>can_enter_jit</tt> hint) notices that all green variables
are the same (here only <tt>i</tt>),
hence we can compile the efficient loop from this point.
</p>
<a href="http://1.bp.blogspot.com/_5R1EBmwBBTs/Sa_b9I8HcVI/AAAAAAAAACI/wuhYwAzZikQ/s1600-h/jit-graph-3.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5309704329111236946" src="http://1.bp.blogspot.com/_5R1EBmwBBTs/Sa_b9I8HcVI/AAAAAAAAACI/wuhYwAzZikQ/s400/jit-graph-3.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand; width: 400px; height: 340px;"></a>

<p>
The loop contains 3 additions and a check (for <tt>i &lt; 100</tt>), exactly
the same as our interpreted program would do, but completely without
interpretation overhead!
</p>
<p>
As you might have noticed, there is no assembler involved so far. All of this
instruction execution is done directly, in pure python. In fact, the
code for executing instructions is located in <tt>jit/backend/llgraph</tt>
which directly interprets instructions. This is by far simpler (and easier
to debug) than x86 assembler.
</p>
<p>
And this is basically it: the very simple interpreter and a jit for it.
Of course we actually <b>can</b> generate assembler for that. Also the missing
piece is optimizing the generated graphs. While for this example,
by removing the interpretetation overhead, we're done, with more complex
examples it's important to further optimize traces. Hopefully this and
how we actually generate assembler will be topics for next blog posts.
</p>
Cheers,<br>
fijal</body></html>