<html><body><p>@Ben: no. In the current incarnation, the JITs generated by PyPy optimize only hot loops, when they are executed more than N times.  At that point, the frame object has already been allocated.<br><br>The real advantage of virtualizables is that they allows to:<br><br>  1) produce very fast code, as if the frame weren't allocated at all (e.g. by storing local variables on the stack or in the registers)<br><br>  2) they don't compromise the compatibility with CPython; in particular, sys._getframe() &amp; co. still works fine, because the JIT knows how and when to synchronize the virtualizable (i.e., the frame) with the values that are on the stack.<br><br><br>@gregturn: I don't see how you can implement something similar to virtualizables without writing a compiler, and CPython is not such a thing :-)</p></body></html>