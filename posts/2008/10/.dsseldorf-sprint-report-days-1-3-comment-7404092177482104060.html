<html><body><p>I'm not sure of what you mean.<br>But modern operating systems (at least Linux) use on-demand loading of executables and libraries, so they never copy anything from an executable file to memory unless it is used.<br><br>In fact, process startup is implemented internally by mmap()ing the executable and libraries into the address space of the new process.<br><br>If you use multiple processes, it still works well - also data pages are shared, until some process writes to them.<br><br>For MMU-less devices, the above does not apply (and ucLinux allows Linux to run on them).<br>But in that case, I guess that no demand loading is available, and that mmap() copies the mapped data in memory - you need to explicitly swap in and out code segments (i.e. to use good old overlays), and no modern programming environment has direct support for them any more I guess.<br><br>You can still emulate overlays with advanced usage of linker scripts however - you put some code in a section, create variables containing the begin and end offset of that section in the linker script, and copy data in memory from that section; but I think that making relocations to that code work flawlessly is impossible, you need to always refer to the buffer containing loaded data.</p></body></html>