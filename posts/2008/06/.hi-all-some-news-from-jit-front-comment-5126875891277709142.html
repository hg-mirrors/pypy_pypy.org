<html><body><p>One thing I've never quite understood: how will the JIT-generation transform interact with more traditional optimization schemes?<br><br>Concrete example: say in a function I want to perform some algebraic reductions of math operations which will change a lot of the instructions.  Since the JIT generation turns the interpreter into a JIT, presumably I have to write the optimization at the interpreter level.  <br><br>I can see how that could work for the simplest kind of optimizations (special cases should be specialized at runtime after they go green, if I understand the rainbow colour scheme.)<br><br>I don't see yet how the more complex optimizations I'd write on static, fixed-type code will look in this context.  IIUC at interpreter level I can only access the JIT's observations via tests like "if type(a) == FloatType" which should be filled after they're known-- but that's inside the function itself, and I don't see how to access that information from anything outside.</p></body></html>