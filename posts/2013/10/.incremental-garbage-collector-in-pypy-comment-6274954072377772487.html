<html><body><p>@Fran√ßois: a flag on the object.  All old objects have this flag initially, and we use it to detect if the write barrier must trigger.  We remove it when the write barrier has triggered once.  We re-add it during the following minor collection.<br><br>@Anonymous: this program is slower on PyPy too.  The point of the benchmark is to show that incminimark gives the same results as minimark, and to show that the JIT has bad cases.  Running the same program for a much longer time (5-10x) lets PyPy slowly catch up and eventually beat CPython by a factor 2.  The memory usage is evening out at around around 4 or 4.5GB (and I'd expect even larger examples to show lower consumption on PyPy, but that's mostly a guess).</p></body></html>