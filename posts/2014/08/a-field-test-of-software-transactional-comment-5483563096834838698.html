<html><body><p>You definitely hit a really weak spot in our report... Today we investigated the ParallelSum benchmark again. So far, we've found out that it was indeed partially a problem with the priority of the benchmark process. The preliminary benchmark results make more sense now and as soon as we have stable ones we will update them.<br><br>I'll still try to address some of your questions right now. :)<br><br>1. Benchmark code<br>I've just wrapped up the current version of our benchmarks and put them in our repository. You can find the two Squeak4.5 images at the <a href="https://bitbucket.org/pypy/lang-smalltalk/src/627db53859875ea0120a4dbf3f21e244174f1618/images/benchmark-images/?at=stmgc-c7" rel="nofollow">stmgc-c7 branch of the RSqueak Repository</a> . You can find the benchmarks in the CPB package. The Squeak4.5stm image needs the RSqueak/STM VM.<br><br>2. Scheduler data structures<br>Yes, the  scheduling data structure is completely unchanged. We have only added a new subclass of Process which overwrites fork and calls a different primitive. However, these Processes are not managed by the Smalltalk scheduler, so there should be no synchronization issues here.<br><br>3. Interference of other processes:<br>This is probably the source of the "speed-up" we observe on the normal RSqueakVM. With more threads we might get a bigger portion of the total runtime. So far, the benchmarks already ran in a VM mode which disables the Smalltalk GUI thread, however in the traces we found that the event handler is still scheduled every now and then. We've done it as you suggested, Stefan, and set the priority to 80 (or 79 to not mess up the timer interrupt handler).<br><br>4. Benchmark harness<br>We actually use SMark and also made sure the timing operations of RSqueak do their job correctly. However we are probably not using SMark at its full potential.</p></body></html>