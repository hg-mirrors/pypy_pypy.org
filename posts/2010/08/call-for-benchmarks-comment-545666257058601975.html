<html><body><p>You could consider Tahoe-LAFS. A good reason to use it is that it is a practicality-oriented, widely deployed tool with significant memory usage that we routinely spend engineering effort to track and manage.<br><br>Here are some graphs of the memory usage of different versions of Tahoe-LAFS over time:<br><br>32-bit machine:<br>http://tahoe-lafs.org/tahoe-figleaf-graph/hanford.allmydata.com-tahoe_memstats.html<br><br>64-bit machine:<br>http://tahoe-lafs.org/tahoe-figleaf-graph/hanford.allmydata.com-tahoe_memstats_64.html<br><br>Here are some open tickets about memory usage in our issue tracker:<br><br>http://tahoe-lafs.org/trac/tahoe-lafs/query?status=!closed&amp;keywords=~memory&amp;order=priority<br><br>The reason not to use Tahoe-LAFS as a subject is that it uses several native-code libraries to for the CPU-intensive inner loops (cryptography, erasure coding). I really want those libraries, and hence Tahoe-LAFS, to be usable with cpyext as soon as possible, but I haven't tried and I assume that cpyext isn't 100% there yet.<br><br>By the way the easiest way to measure the performance of Tahoe-LAFS would be to run its unit tests and measure the memory usage and runtime. This is not only the easiest way, but it is also a pressing issue for us! Tahoe-LAFS unit tests take too long to run, and this causes problems for us, and we very much like it if they could run to completion faster. <br><br>http://tahoe-lafs.org/trac/tahoe-lafs/ticket/20# unit tests take too long<br><br>Here are our buildbots showing unit test runtime among other things:<br><br>http://tahoe-lafs.org/buildbot/waterfall?show_events=true&amp;builder=Kyle+OpenBSD-4.6+amd64&amp;builder=hardy-amd64&amp;builder=Arthur+lenny+c7+32bit&amp;builder=Eugen+lenny-amd64&amp;builder=David+A.+OpenSolaris+i386&amp;builder=Ruben+Fedora&amp;builder=Zooko+zomp+Mac-amd64+10.6+py2.6&amp;builder=FreeStorm+WinXP-x86+py2.6&amp;builder=tarballs</p></body></html>