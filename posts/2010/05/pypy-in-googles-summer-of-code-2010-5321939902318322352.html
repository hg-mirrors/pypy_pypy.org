<html><body><p>Good news everyone.</p>
<p>This year, thanks to <a class="reference external" href="http://google.com">google</a> generosity and <a class="reference external" href="http://www.python.org/psf/">PSF</a> support, we got two and a
half of students for PyPy's summer of code. We didn't cut any students, but one
of the projects is a joint project of PyPy and <a class="reference external" href="http://numpy.scipy.org/">numpy</a>. Hereby I present
descriptions, in my own words with my own opinions and in arbitrary order.  For
more details please follow links to particular blogs.</p>
<div class="section" id="jason-creighton-64bit-jit-backend-for-pypy">
<h3><a class="reference external" href="http://jcreigh.blogspot.com/">Jason Creighton</a>: 64bit JIT backend for PyPy</h3>
<p>Intel 64bit (and I mean <a class="reference external" href="http://en.wikipedia.org/wiki/X86_64">x86_64</a>) compatibility for JIT has been one of the top
requested features (along with GIL removal). While GIL removal is not really an
easy task, having our JIT emit 64bit assembler is sort of easy, thanks to our
JIT backend abstraction. It will likely be faster, thanks to abundance of
registers.</p>
</div>
<div class="section" id="bartosz-skowron-fast-ctypes-for-pypy">
<h3><a class="reference external" href="http://hack.bartskowron.com/">Bartosz Skowron</a>: Fast ctypes for PyPy</h3>
<p>Historically weak point of PyPy was compatibility with extension modules.  We
have progressed quite a bit in recent years, first introducing <a class="reference external" href="http://docs.python.org/library/ctypes.html">ctypes</a> for
pypy then progressing towards <a class="reference external" href="http://morepypy.blogspot.com/2010/04/using-cpython-extension-modules-with.html">CPython extension modules</a>. However, ctypes is
well known to be slow (and it's even slower on PyPy) and writing CPython
extension modules is ugly, and it's going to be only with compatibility layer
that'll keep this slow. What happens if we try to employ JIT technology to
ctypes? Maybe we can compile calls to C code from Python as a direct calls in
compiled assembler? Why not?</p>
<p>This project will look how the JIT technology can be employed to do some
sort of FFI. There is no guarantee we'll get super-fast ctypes as a result,
but it's good to see progress in that area.</p>
</div>
<div class="section" id="dan-roberts-numpy-in-pypy">
<h3><a class="reference external" href="http://ademan.wordpress.com/">Dan Roberts</a>: Numpy in PyPy</h3>
<p>This is a joint project of numpy and PyPy. The main objective is to bring
numpy to PyPy, possibly fast. The official mentor for this project is
Stefan van der Walt from numpy community. During initial meeting it was
agreed that probably the best way to go would be to support original numpy
with CPython extension compatibility and then provide a minimal native numpy
framework for pypy. The former would retain full compatibility, while the
latter would have JIT integration, with line of our previous
<a class="reference external" href="http://morepypy.blogspot.com/2009/07/pypy-numeric-experiments.html">numeric experiments</a>. There would be an explicit interface from converting
one array to another for convinience.</p>
</div>
<p>Overall, I'm very happy to see so much support for PyPy from SoC. I hope all
three proposals will be successful!</p>
<p>Cheers,<br>
fijal &amp; pypy team.</p></body></html>