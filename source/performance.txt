One of the goals of the PyPy project is to provide a fast and compliant python
interpreter. Part of the way we achieve this is to provide a high-performance
garbage collector and a high performance JIT. Results of comparing PyPy and
CPython can be found on the `speed website`_. Those benchmarks are not a random
collection. They're a combination of real-world Python programs, benchmarks
originally included and benchmarks we found PyPy to be slow on. Consult
descriptions of each for details.

JIT is however not a magic bullet. There are several characteristics that might
be surprising for people having first encounter with it. JIT is generally good
at speeding up straightforward python code that spends a lot of time in
the bytecode dispatch loop, numerics, heave oo etc. When JIT does not help,
PyPy is generally slower than CPython, those things include:

* **Tests**: Ideal unit tests would execute each piece of tested code which
  leaves no time for the JIT to warm up.

* **Really short-running scripts**: A rule of thumb is if something runs below
  0.2s JIT has no chance, but it depends a lot on the program in question. In
  general, make sure you warm up your program before running benchmarks if
  you're measuring something long-running like a server.

* **Functions in runtime**: Functions that take significant time in runtime.
  PyPy's runtime is generally not as optimized as CPython's and expect those
  functions to take somewhere between same time as CPython to 2x longer.
  XXX explain exactly what runtime is

Unrelated things that we know PyPy is slow at (note that we're probably working
on it):

* **Long integers**

* **Building very large dicts**

XXX

We generally consider things that are slower on PyPy than CPython PyPy's bugs.
In case you find a thing that's not documented here, report it to our
`bug tracker`_ for investigation

.. _`bug tracker`: http://bugs.pypy.org
.. _`speed website`: http://speed.pypy.org

